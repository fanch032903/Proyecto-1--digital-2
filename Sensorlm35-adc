//********************************************/
//Universidad del Valle de Guatemala
//BE3029 - Electrónica Digital 2
// Fátima Camposeco-23122
// Proyecto 1
//MCU: ESP32 dev kit 1.0
//********************************************/

#include <Arduino.h>
#include <stdint.h>
#include "config.h"           // Personal para Adafruit 
#include <AdafruitIO_WiFi.h>  // librería de Adafruit IO

//Definir pines para sensor de temperatura
#define PIN_LM35   34 //ADC del esp32
#define PIN_boton1 18 

//LED RGB-separada
#define LED_R 5 //Roja
#define LED_G 2 //Verde
#define LED_B 4 //Amarilla 

//PIN SERVO
#define SERVO_PIN 19

//Canales PWM
#define CH_R 0       //LED Roja
#define CH_G 1       //LED Verde
#define CH_B 2       //LED Amarilla
#define CH_SERVO 3   //Servo

//Definimos datos PWM para LEDS
#define FREQ 5000 
#define RESOLUTION 8 //Resolución PWM (0-255)

//Datos PWM para Servo
#define FREQ_SERVO 50
#define RESOLUTION_SERVO 8 

//Prototipo de funciones 
float getADCPromedio(void);
void actualizarSemaforo(float temp);
void actualizarServo(float temp);

//Variables globales 
int adcRaw = 0; 
float promedioLecturas = 0; 
float temperaturaC = 0; 
int dutyServo = 0;

// Adafruit IO
#define IO_LOOP_DELAY 5000
unsigned long lastUpdate = 0;

//Feeds 
AdafruitIO_Feed *canaltemp = io.feed("temperatura");
AdafruitIO_Feed *canalLED  = io.feed("relojtemp");

void setup() {
  Serial.begin(115200); //Se inicia la comunicación serial 

  // --- Conexión a Adafruit IO
  while(! Serial);
  Serial.print("Conectando a Adafruit IO");
  io.connect();
  while(io.status() < AIO_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println();
  Serial.println(io.statusText());

  //Pines Sensor y botón 
  pinMode(PIN_boton1, INPUT_PULLUP);
  pinMode(PIN_LM35, INPUT);

  //PWM para LEDs
  ledcSetup(CH_R, FREQ, RESOLUTION);
  ledcSetup(CH_G, FREQ, RESOLUTION);
  ledcSetup(CH_B, FREQ, RESOLUTION);

  ledcAttachPin(LED_R, CH_R);
  ledcAttachPin(LED_G, CH_G);
  ledcAttachPin(LED_B, CH_B);

  //PWM para servo 
  ledcSetup(CH_SERVO, FREQ_SERVO, RESOLUTION_SERVO);
  ledcAttachPin(SERVO_PIN, CH_SERVO);

  //Servo inicia en centro
  ledcWrite(CH_SERVO, 19);
}

void loop() {
  //Solo se va a leer si se presiona el botón
  if (digitalRead(PIN_boton1) == LOW) {
    promedioLecturas = getADCPromedio(); 
    int mV = analogReadMilliVolts(PIN_LM35); 
    temperaturaC = mV / 10.0; 

    //Mostrar valores
    Serial.print("ADC promedio: ");
    Serial.println(promedioLecturas);
    Serial.print("Temperatura: ");
    Serial.print(temperaturaC);
    Serial.println(" °C");

    //Actualizar LEDs y Servo
    actualizarSemaforo(temperaturaC);
    actualizarServo(temperaturaC);

    // Enviar los datos a Adafruit 
    canaltemp->save(temperaturaC);
    //Visualizar color del semáforo 
    if (temperaturaC < 26.0) {
      canalLED->save((String)"#288e23"); // Verde 
    }
    else if (temperaturaC >= 26.0 && temperaturaC < 28.0) {
      canalLED->save((String)"#d0e213"); // Amarillo
    }
    else {
      canalLED->save((String)"#882522"); // Rojo
    }

    delay(500);
  }
}

// Función promedio de lecturas ADC
float getADCPromedio(void) {
  int numeroLecturas = 10;
  int sumaLecturas = 0;

  for (int k = 0; k < numeroLecturas; k++) {
    sumaLecturas += analogRead(PIN_LM35);
    delay(1);
  }

  float promedio = sumaLecturas / (numeroLecturas * 1.0);
  return promedio;
}

void actualizarSemaforo(float temp) {
  //Apagar todas
  ledcWrite(CH_R, 0);
  ledcWrite(CH_G, 0);
  ledcWrite(CH_B, 0);

  if (temp < 26.0) {
    ledcWrite(CH_G, 255); // Verde 
  }
  else if (temp >= 26.0 && temp < 28.0) {
    ledcWrite(CH_B, 255); // Amarillo
  }
  else {
    ledcWrite(CH_R, 255); // Rojo
  }
}

void actualizarServo(float temp) {
  // Tres posiciones fijas según rango de temperatura
  if (temp < 26.0) {
    dutyServo = 6;   // Posición izquierda (frío)
  }
  else if (temp >= 26.0 && temp < 28.0) {
    dutyServo = 19;  // Posición centro (templado)
  }
  else {
    dutyServo = 32;  // Posición derecha (caliente)
  }

  ledcWrite(CH_SERVO, dutyServo);

  Serial.print("Servo duty (posición fija): ");
  Serial.println(dutyServo);
}

//===Display==

// Configurar pines del display
void configDisplay7(void) {
  pinMode(dA, OUTPUT); pinMode(dB, OUTPUT);
  pinMode(dC, OUTPUT); pinMode(dD, OUTPUT);
  pinMode(dE, OUTPUT); pinMode(dF, OUTPUT);
  pinMode(dG, OUTPUT); pinMode(dP, OUTPUT);

  pinMode(DIG1, OUTPUT);
  pinMode(DIG2, OUTPUT);
  pinMode(DIG3, OUTPUT);

  digitalWrite(DIG1, HIGH);
  digitalWrite(DIG2, HIGH);
  digitalWrite(DIG3, HIGH);
}

// Case para cada digito 
void desplegarNumero(uint8_t n) {
  switch (n) {
    case 0: digitalWrite(dA,LOW); digitalWrite(dB,LOW); digitalWrite(dC,LOW); digitalWrite(dD,LOW); digitalWrite(dE,LOW); digitalWrite(dF,LOW); digitalWrite(dG,HIGH); break;
    case 1: digitalWrite(dA,HIGH); digitalWrite(dB,LOW); digitalWrite(dC,LOW); digitalWrite(dD,HIGH); digitalWrite(dE,HIGH); digitalWrite(dF,HIGH); digitalWrite(dG,HIGH); break;
    case 2: digitalWrite(dA,LOW); digitalWrite(dB,LOW); digitalWrite(dC,HIGH); digitalWrite(dD,LOW); digitalWrite(dE,LOW); digitalWrite(dF,HIGH); digitalWrite(dG,LOW); break;
    case 3: digitalWrite(dA,LOW); digitalWrite(dB,LOW); digitalWrite(dC,LOW); digitalWrite(dD,LOW); digitalWrite(dE,HIGH); digitalWrite(dF,HIGH); digitalWrite(dG,LOW); break;
    case 4: digitalWrite(dA,HIGH); digitalWrite(dB,LOW); digitalWrite(dC,LOW); digitalWrite(dD,HIGH); digitalWrite(dE,HIGH); digitalWrite(dF,LOW); digitalWrite(dG,LOW); break;
    case 5: digitalWrite(dA,LOW); digitalWrite(dB,HIGH); digitalWrite(dC,LOW); digitalWrite(dD,LOW); digitalWrite(dE,HIGH); digitalWrite(dF,LOW); digitalWrite(dG,LOW); break;
    case 6: digitalWrite(dA,LOW); digitalWrite(dB,HIGH); digitalWrite(dC,LOW); digitalWrite(dD,LOW); digitalWrite(dE,LOW); digitalWrite(dF,LOW); digitalWrite(dG,LOW); break;
    case 7: digitalWrite(dA,LOW); digitalWrite(dB,LOW); digitalWrite(dC,LOW); digitalWrite(dD,HIGH); digitalWrite(dE,HIGH); digitalWrite(dF,HIGH); digitalWrite(dG,HIGH); break;
    case 8: digitalWrite(dA,LOW); digitalWrite(dB,LOW); digitalWrite(dC,LOW); digitalWrite(dD,LOW); digitalWrite(dE,LOW); digitalWrite(dF,LOW); digitalWrite(dG,LOW); break;
    case 9: digitalWrite(dA,LOW); digitalWrite(dB,LOW); digitalWrite(dC,LOW); digitalWrite(dD,LOW); digitalWrite(dE,HIGH); digitalWrite(dF,LOW); digitalWrite(dG,LOW); break;
    default: digitalWrite(dA,HIGH); digitalWrite(dB,HIGH); digitalWrite(dC,HIGH); digitalWrite(dD,HIGH); digitalWrite(dE,HIGH); digitalWrite(dF,HIGH); digitalWrite(dG,HIGH); break;
  }
}

// Multiplexeo 3 dígitos con punto decimal
void mostrarNumero(float valor) {
  if (valor < 0) valor = 0;
  if (valor > 99.9) valor = 99.9;

  //Hacer el calculo para que se pueda redondear y ver el valor correcto
  int t10 = (int)(valor * 10 + 0.5);
  int decenas  = (t10 / 100) % 10;
  int unidades = (t10 / 10) % 10;
  int decimas  = t10 % 10; 

  // Dígito 1
  digitalWrite(DIG1, LOW);
  desplegarNumero(decenas);
  digitalWrite(dP, HIGH);
  delay(3);
  digitalWrite(DIG1, HIGH);

  // Dígito 2 incluye el punto 
  digitalWrite(DIG2, LOW);
  desplegarNumero(unidades);
  digitalWrite(dP, LOW); 
  delay(3);
  digitalWrite(DIG2, HIGH);

  // Dígito 3
  digitalWrite(DIG3, LOW);
  desplegarNumero(decimas);
  digitalWrite(dP, HIGH);
  delay(3);
  digitalWrite(DIG3, HIGH);
}

